/* deno-fmt-ignore */ import { numbered,assertObjectValue, pause, joinPath, expandPath, fooga, Matrix, isInteger, isEquation, isObjectObject, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit , coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, ass, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
    ///  Error
import * as variables from "/home/kdog3682/2023/variables.js"
import * as datetime from "/home/kdog3682/2024-javascript/datetime/main.js"
import {LineEditor, getDashedText } from "/home/kdog3682/2024-javascript/js-toolkit/LineEditor.js"
import { copySync } from "https://deno.land/std@0.220.1/fs/copy.ts"
let denoFileRunner
export {
    absdir,
    append,
    bash,
    clip,
    cpdir,
    cwd,
    deleteFiles,
    denoFileRunner,
    denoImports,
    forceWrite,
    getAppFunction,
    getFiles,
    getModuleFunc,
    getMostRecentFile,
    getVimSectionText,
    isDir,
    isFile,
    moveFiles,
    mv,
    notify,
    npath,
    openFile,
    panicPrompt,
    read,
    readdir,
    rename,
    requestAppend,
    requestWrite,
    rmdir,
    rpw,
    select,
    sysArgs,
    textAndLang,
    unzip,
    write,
    xselect,
}

import { open } from "https://deno.land/x/open/index.ts"

import * as chalk from "../js-toolkit/chalk.js"

function read(file) {
    file = expandPath(file)
    const text = Deno.readTextFileSync(file)
    if (isJsonParsable(text)) {
        return JSON.parse(text)
    }
    return text
}

function write(file, content, confirmation) {
    if (!exists(content)) {
        return
    }
    if (isObjectObject(content)) {
        throw new Error("[object Object]")
    }

    const data = typeof content == "object"
        ? stringify(content)
        : content

    file = expandPath(file)
    if (confirmation) {
        const message = `Do you wish to write file: ${file}?`
        chalk.blue("-".repeat(50))
        console.log(content)
        chalk.blue("-".repeat(50))
        console.log(message)
        console.log("")
        if (!confirm("")) {
            return
        }
    }
    Deno.writeTextFileSync(file, data)
    announce(file)
}

function openFile(file) {
    return
    if (!file) {
        return
    }
    file = expandPath(file)
    if (isFile(file)) {
        open(file)
    }
}

function sysArgs() {
    return Deno.args.map(shellUnescape)
}

function bash(...input) {
    const args = input.length == 1
        ? xsplit(input[0])
        : flat(input)
    const cmd = args.join(" ")
    if (Deno.debug_bash) {
        pause("bash cmd", cmd)
    }
    const a = args.shift()
    const command = new Deno.Command(a, { args })
    const result = command.outputSync()
    const stdout = new TextDecoder().decode(result.stdout).trim()
    const stderr = new TextDecoder().decode(result.stderr).trim()
    const success = result.success
    return { stdout, success, stderr }
}

function rpw(file, fn, confirmation) {
    return write(file, fn(read(file)), confirmation)
}

function readdir(dir, mode = "") {
    const mapper = (file) => {
        if (mode == "files" && !file.isFile) {
            return
        }
        if (mode == "folders" && !file.isDirectory) {
            return
        }
        return joinPath(dir, file.name)
    }

    return Array.from(Deno.readDirSync(expandPath(dir)), mapper)
        .filter(
            isDefined,
        )
}

function cwd() {
    return Deno.cwd()
}

function append(file, content, confirmation) {
    if (!file) {
        return
    }
    if (!exists(content)) return

    if (isObjectObject(content)) {
        throw new Error("[object Object]")
    }
    file = expandPath(file)

    if (isString(content)) {
        if (confirmation) {
            confirmWrite(file, content)
        }
        Deno.writeTextFileSync(file, content, { append: true })
    } else {
        const prev = read(file) || getFallback(content)
        const payload = isArray(prev)
            ? prev.concat(content)
            : Object.assign(prev, content)
        if (confirmation) {
            confirmWrite(file, payload)
        }
        Deno.writeTextFileSync(file, stringify(payload))
    }
    announce(file)
}

function announce(x) {
    const caller = getCaller(1).name
    const ref = {
        "append": "appending file",
        "foo": "fooing file",
        "write": "writing file",
        "clear": "clearing file",
    }
    console.log(ref[caller] + ":", x)
}

function requestWrite(a, b) {
    return write(a, b, true)
}

function errorPrompt(e) {
    console.log("ERROR")
    console.log(getCaller(1))
    return prompt(e.toString())
}

function panicPrompt(s, ref) {
    prompt(templater(s, ref))
    throw ""
}

function getStats(file) {
    const keys = [
        "size",
        "mtime",
        "isFile",
        "isDirectory",
    ]
    try {
        return Deno.lstatSync(file)
    } catch (e) {
        pause(e.toString(), file)
        console.log("ERRORRRRRRRR", e.stack)
    }
}

function getMostRecentFile(dir) {
    const files = readdir(dir)
    return getLongest(
        files,
        (x) => getStats(x).mtime.getTime(),
        null,
    )
}

function isDir(dir) {
    try {
        const res = Deno.lstatSync(dir)
        return res.isDirectory
    } catch (e) {
        return false
    }
}

function isFile(file) {
    try {
        return Deno.lstatSync(file).isFile
    } catch (e) {
        return false
    }
}

function textAndLang(s) {
    s = s.toString().trim()
    if (isFile(s)) {
        return {
            file: s,
            lang: getExtension(s),
            filetype: getFiletype(s),
            text: read(s),
        }
    } else {
        const lang = inferLang(s)
        return {
            file: null,
            lang,
            filetype: getFiletype(lang),
            text: s,
        }
    }
}

function npath(dir, file, ext) {
    if (ext) {
        file = addExtension(file, ext)
    }
    const name = tail(file)
    return joinPath(dir, name)
}
function notify(a, b) {
    console.log(b)
    console.log(a)
    return prompt("press anything to continue")
}
function denoImports(a, b) {
    if (isArray(b)) {
        return `/* deno-fmt-ignore */ import { ${
            b.join(", ")
        } } from "${a}"`
    } else {
        return `/* deno-fmt-ignore */ import * as ${b} from "${a}"`
    }
}
function confirmWrite(file, payload) {
    console.log(
        "please confirm you wish to write the file",
        file,
    )
    console.log("----")
    console.log(payload)
    console.log("----")
    return confirm("")
}
function requestAppend(file, payload) {
    return append(file, payload, true)
}
function clear(file) {
    Deno.writeTextFileSync(file, "")
}

async function getModuleFunc(file) {
    let module
    try {
        module = await import(file)
    } catch (e) {
        if ((isStandardError(e))) {
            console.log(file)
            throw e
        }
    }
    return must(
        module,
        "default",
        "no module.default fn exists for the file: $1",
        file,
    )
}
async function fzf() {
    const { FZF } = await import("https://esm.sh/fzf")

    const fzf = new Fzf(items)
    console.log(items)
    while (true) {
        const ents = fzf.find(prompt("query"))
        const ranking = ents.map((entry) => entry.item).join(
            ", ",
        )
        console.log(ranking)
    }
}
async function getAppFunction(url, key) {
    const base = isRelativePath(url)
        ? npath(head(getLast(getErrorStack())[1]), url)
        : url
    const p = joinPath(base, addExtension(key, "js"))
    ass(p, isFile)
    return await getModuleFunc(p)
}

function head(dir) {
    const a = dir.replace(/\/[\w.]+\/?$/, "")
    if (a == "") {
        return Deno.cwd()
    }
    return expandPath(a)
}
function isStandardError(e) {
    return e instanceof Error &&
        (e.name == "ReferenceError" || e.name == "SyntaxError")
}

function getVimSectionText(vim) {
    const s = read(vim.file)
    const lnum = vim.lnum || vim.lineNumber
    const text = getDashedText(s, lnum)
    return text
}
function isRelativePath(url) {
    return url.startsWith("./")
}

async function getInput() {
    const result = await Deno.stdin.readable.getReader().read()
    return new TextDecoder().decode(result.value)
}
async function setup() {
    Deno.stdin.setRaw(true)
    while (true) {
        console.log("awaiting")
        const a = await getInput()
        console.log({ a })
        return
    }
}

async function typstCompile(o = {}) {
    const base = [
        "typst",
    ]
    if (o.watch) {
        base.push("watch")
    } else {
        base.push("compile")
    }

    const file = must(o, "file")

    const outpath = o.outpath
        ? o.outpath
        : svg
        ? "/home/kdog3682/2023/test.svg"
        : "/home/kdog3682/2023/test.pdf"

    base.push(file)
    base.push(outpath)

    if (o.open) {
        base.push("--open")
    }
    if (o.fonts) {
        base.push("--fonts")
    }
    base.push("--root")
    base.push("/")

    const result = await bash(base)
    return result.success
}

// Deno.debug_bash = 1
async function boo() {
    file = "/home/kdog3682/2024-typst/src/foo.typ"
    if (!a) {
        return
    }
    const text = read(file)
    createHtml()
}

function xpath(...args) {
    let ext
    if (extensions.includes(getLast(args))) {
        ext = args.pop()
    }
    let name = args.pop()
    if (ext) {
        name = addExtension(name, ext)
    }
    if (args.length) {
        name = tail(name)
    }
    return joinPath(...args, name)
}

function mkdir(dir) {
    dir = expandPath(dir)
    try {
        Deno.mkdirSync(dir, { recursive: true })
        console.log("created dir", dir)
        return true
    } catch (e) {
        return false
    }
}
function cpdir(a, b) {
    a = expandPath(a)
    b = expandPath(b)
    if (isDir(b)) {
        pause("deleting the dir")
        rmdir(b)
    }
    console.log("b", b)
    console.log(copySync(a, b))
}

function cp(a, b) {
    if (isFile(a)) {
        Deno.copyFileSync(a, b)
    }
}
async function createTypstHtmlFileJson(file, name) {
    if (!name) {
        name = must(prompt("please name this project"))
    }
    name = snakeCase(name)
    pause("pausing @ name", name)

    const dir = "/home/kdog3682/2024-javascript/typstdoc/"
    mkdir(xpath(dir, "assets"))

    const svgpath = xpath(dir, "assets", name, "svg")
    console.log("svgpath", svgpath)
    const textpath = xpath(dir, "assets", name, "txt")
    console.log("textpath", textpath)
    const jsonpath = xpath(dir, "index.json")
    console.log("jsonpath", jsonpath)
    pause()

    const a = await typstCompile({ file, outpath: svgpath })
    if (!a.success) {
        console.log(a)
        return
    }
    cp(file, textpath)
    append(jsonpath, [{ timestamp: Date.now(), name }])
    printdir(dir)
}

function printdir(dir) {
    getFilesRecursive
}

function dirGetter(dir) {
    dir = expandPath(dir)
    if (isDir(dir)) {
        return dir
    }
    pause("not a dir", dir, isDir(dir), "aa")
    throw "not a dir"
    return dir
}
function getFiles(dir, options = {}) {
    const o = options
    const targets = []
    const targetRE = o.target && toRegExp(o.target)
    dir = dirGetter(dir)
    function parse(path, stats) {
        if (targetRE && targetRE.test(path)) {
            targets.push(path)
        }
        return path
    }
    const checkpoint = checkpointf(options)

    function flatted(dir) {
        const items = absdir(dir)
        const contents = items.map(inner).filter(isDefined)
        return contents
    }
    function nested(dir) {
        const items = readdir(dir)
        const contents = items.map(inner).filter(isDefined)
        return { dir, contents, size: contents.length }
    }
    const runner = options.flat ? flatted : nested
    const results = runner(dir)
    if (exists(targets)) {
        return targets
    }
    if (options.flat) {
        return flat(results)
    }
    return results

    function inner(path) {
        const stats = getStats(path)

        if (!checkpoint(path, stats)) {
            return
        }

        if (options.recursive) {
            if (stats.isDirectory) {
                return runner(path)
            } else {
                return parse(path, stats)
            }
        } else {
            return parse(path, stats)
        }
    }
}

function checkpointf(o = {}) {
    function parseTime(key) {
        const currentTime = Date.now()
        const ref = {
            "week": 168,
            "month": 576,
        }
        if (ref.hasOwnProperty(key)) {
            return Date.now() - ref[k] * 3600000
        }
        todo()
    }

    const smallerThan = o.smallerThan
    const biggerThan = o.biggerThan
    const after = o.after && parseTime(o.after)
    const before = o.before && parseTime(o.before)
    const nameRE = o.name && toRegExp(o.name)

    const ignoreRE = o.ignoreRE
    const ignore = xsplit2(o.ignore)
    let extensions = xsplit2(o.extensions)

    for (const ext of variables.extensions) {
        if (ext in o) {
            extensions.push(ext)
        }
    }

    const privateRE = /^[~=.]/

    if (empty(extensions)) {
        extensions = null
    }

    function checkpoint(file, stats) {
        const name = tail(file)
        const e = getExtension(name)
        if (
            o.public && privateRE.test(name) ||
            ignore && ignore.includes(name) ||
            ignoreRE && ignoreRE.test(name) ||
            nameRE && !nameRE.test(name) ||
            extensions && !extensions.includes(e) ||
            before && stats.mtime.getTime() > before ||
            after && stats.mtime.getTime() < after ||
            smallerThan && smallerThan > stats.size ||
            biggerThan && biggerThan < stats.size ||
            o.onlyFiles && stat.isDir ||
            o.onlyDirs && stat.isFile ||
            false
        ) {
            return false
        }
        return true
    }
    return checkpoint
}
// createTypstHtmlFileJson('/home/kdog3682/2024-typst/src/foo.typ', 'dotted triangles')

// console.log(getStats('/home/kdog3682/2023/utils.js'))
function forceWrite(file, content) {
    mkdir(head(file))
    write(file, content)
}
function rm(x) {
    x = expandPath(x)
    if (isDir(x)) {
        Deno.removeSync(x, { recursive: true })
    } else {
        Deno.removeSync(x)
    }
}
function rmdir(dir) {
    try {
        Deno.removeSync(expandPath(dir), { recursive: true })
        return true
    } catch (e) {
        console.log(e)
        return false
    }
}
function trial(fn, ...args) {
    try {
        return fn(...args)
    } catch (e) {
        pause(e.toString(), ...args)
    }
}

function absdir(dir) {
    function mapper(file, dir) {
        return trial(joinPath, dir, file.name)
    }
    return Array.from(Deno.readDirSync(expandPath(dir))).map((
        x,
    ) => mapper(x, dir))
}
function clip(s) {
    write("/home/kdog3682/2023/clip.js", s)
    openFile("/home/kdog3682/2023/clip.js")
}

function rename(a, b) {
    a = expandPath(a)
    b = expandPath(b)
    Deno.renameSync(a, b)
    console.log("renaming", a, b)
}
function mv(a, b) {
    a = expandPath(a)
    b = expandPath(b)
    if (isDir(b)) {
        b = npath(b, a)
        pause('copying', a, 'to', b)
    }
    try {
        Deno.renameSync(a, b)
    } catch (e) {
        if (e.message.startsWith("Invalid cross-device link (os error 18)")) {
            console.log('error', e.message)
            console.log('trying with bash')
            console.log(bash('sudo', 'cp', a, b))
        }
        return
    }
    console.log("moving", a, b)
}
function deleteFiles(a, b) {
    const files = absdir(a)
    const chosen = select(files, { multiple: true })
    pause("chosen", chosen)
    chosen.map(rm)
}

function moveFiles(a, b) {
    const files = absdir(a)
    mkdir(b)
    const chosen = select(files, { multiple: true })
    pause("chosen", chosen)
    chosen.map((x) => mv(x, b))
}
function select(items, o) {
    function mapper(x) {
        const ind = Number(x) - 1
        return items[ind]
    }

    if (items.length == 0) {
        return
    }
    if (items.length == 1) {
        return items[0]
    }
    numbered(items)
    const a = prompt("choose 1-based indexes")
    assert(a)
    return xsplit(a).map(mapper)
}

async function unzip(file, to) {
    const { decompress } = await import(
        "https://deno.land/x/zip@v1.2.5/mod.ts"
    )
    return decompress(file, expandPath(to))
}

function xselect(x) {
    if (isDir(x)) {
        return smallify(xselect(absdir(x)))
    }
    return select(x)
}
// clip('abc')
// await open('/home/kdog3682/2023/utils.js', {url: true, wait: true});

function jstr(...args) {
    const keys = [
        "if",
        "else",
        "else if",
        "while",
        "for",
    ]

    let s = ''
    function get(i) {
        let arg = args[i]
        if (isArray(arg)) {
            arg = jstr(...arg)
        }
        return arg
    }
    for (let i = 0; i < args.length; i++) {
        let arg = get(i)
            if (keys.includes(arg)) {
                s += arg
                s += ' (' + get(++i) + ') '
                s += brackify(get(++i))
                s += '\n'
            }
    }
    return s
}
function saveErrorToLine(e) {
    const s = jstr('if', 'e.message == "$1"', 'copySync(a, b)', )
    appendBelow(getCaller('self'), s)
}

function appendBelow(x, text) {
    const file = x.file
    const line = x.hasOwnProperty("lnum")
        ? x.lnum
        : x.hasOwnProperty("line")
        ? x.line
        : x.hasOwnProperty("lineNumber")
        ? x.lineNumber
        : null

    const editor = new LineEditor(read(file))

    editor.setPos(line - 1)
    editor.insertBelow(text)
    const s = editor.toString()
    write(file, s)
}
